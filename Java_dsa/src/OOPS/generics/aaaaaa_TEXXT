*** actual type argument (like Integer in <Integer>) is not retained in the bytecode ***

At compile time, the compiler ensures type safety (only Integer can be added to integerList).
But at runtime, due to type erasure, List<Integer> becomes just List,
and thereâ€™s no way to determine that integerList was parameterized with Integer.

So, instead of replacing <E> with Integer, the type parameter is erased and replaced with the raw type (like List),
and any operations involving type parameters are handled using casting or Object.
--------------------------------------------------------------------------------------------------------

bounded vs unbounded parameters:-
(checking type-safety at compile-time)
before - List<T> is unbounded
after - T is replaced by Object, which superclass of all classes
before - List<T extends Number> is bounded
after - T is replaced by Number class

--------------------------------------------------------------------------------------------------------

Box<Integer> is not a subtype of Box<Number> even though Integer is a subtype of Number.
we use wildcards to solve this,
wildcards --> <?>
Box<? extends Number> will take in <Integer> and <Double>

List<B> lb = new ArrayList<>();
List<A> la = lb;   // compile-time error

List<? extends Integer> intList = new ArrayList<>();
List<? extends Number>  numList = intList;
// OK. List<? extends Integer> is a subtype of List<? extends Number>

Given two concrete types A and B (for example, Number and Integer),
MyClass<A> has no relationship to MyClass<B>, regardless of whether or not A and B are related.
The common parent of MyClass<A> and MyClass<B> is Object

Box<Number> box = new Box<Number>();
box.add(new Integer(10));   // OK
box.add(new Double(10.1));  // OK

public void boxTest(Box<Number> n) { /* ... */ }
What type of argument does it accept? By looking at its signature,
you can see that it accepts a single argument whose type is Box<Number>.
But what does that mean? Are you allowed to pass in Box<Integer> or Box<Double>, as you might expect?
The answer is "no", because Box<Integer> and Box<Double> are not subtypes of Box<Number>.

-----------------------------------------------------------------------------------------------------------

<? super Integer> super is lower bound, Integer and its parent classes
<? extends Integer> extends is upper bound, Integer and its sub classes

Use <? super T> when you need to write to a generic collection.
Use <? extends T> when you need to read from a generic collection.

List<? extends Integer> list = new ArrayList<>();
list.add(42); // Error: you cannot add to a list using <? extends Integer>
// you can still add null though
Integer value = list.get(0); // This works